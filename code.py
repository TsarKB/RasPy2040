## SPDX-FileCopyrightText: 2021 Nick Bell Aviator Ortho 40%
# SPDX-License-Identifier: MIT
# RaspberryPi Pico RP2040 Keyboard

import time
import microcontroller
import board
from digitalio import DigitalInOut, Direction, Pull
import usb_hid
from adafruit_hid.keyboard import Keyboard
from adafruit_hid.keycode import Keycode
from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS
from adafruit_hid.consumer_control import ConsumerControl
from adafruit_hid.consumer_control_code import ConsumerControlCode
from tsar import tsar
import keymap

time.sleep(1.00) # Try to prevent a race condition with other peripherals

#Initialize the keyboard and layout.
kbd        = Keyboard(usb_hid.devices)
cc         = ConsumerControl(usb_hid.devices)
kbd_layout = KeyboardLayoutUS(kbd)

#Tell the board to restart in safe mode
microcontroller.on_next_reset(microcontroller.RunMode.NORMAL)

#Define the rows and columns that the wires or traces that are connected to your board.
# These are defined in your keymap file.
ROWS  = keymap.ROWS
COLS  = keymap.COLS

DT_THRESHOLD   = keymap.DT_END
HOLD_THRESHOLD = keymap.HOLD_TIME

userKeymap = tsar.initializeLayerMap(keymap.keymap)
# print('Finished Initializing keymap.')

layer = 0 #Start at layer 0. This determines which layer of keys you'll be using when holding modifier keys.

switches = tsar.mapSwitches(ROWS,COLS)
for encoder in range(len(keymap.encoder_map)) :
    tsar.initializeRotaryEncoders(keymap.encoder_map[encoder])

for toggle in range(len(keymap.toggle_map)) :
    tsar.initializeToggleSwitches(keymap.toggle_map[toggle])

# Handles the key press functionality.
# Params:
#   key - Dictionary - Key object generated by initializeLayerMap.
#   forceValue - Boolean - If there is a secondary key to be pressed, set this to True. Used for HOLD and Double-Tap functionality.
def keyPress (key, forceValue) :

    global layer

    keyValue = key['value']
    keyType  = key['type']
    print(layer)
    if key['debounce'] :
        # If the key being pressed is held down or part of a double-tap action, return so we don't accidentally press it over and over.
        return
    
    key['status'] = 1 #set the "status" of the key to one to stop us from re-sending over and over again.
    
    if forceValue :
        keyValue = key['altValue']
        keyType  = key['altType']
    
    
    try :

        if key['altFunc'] == keymap.HOLD and key['dt'] == 0:
            return # If the key is held, don't perform the first key press.

        if keyType == keymap.MED:
            cc.send(keyValue)
        elif keyType == keymap.KEY:
            kbd.press(keyValue)
        elif keyType == keymap.LSW:
            layer = keyValue
        elif keyType == keymap.MAC:
            kbd.send(*keyValue)
        elif keyType == keymap.STR:
            kbd_layout.write(keyValue)
        elif keyType == keymap.RES:
            if keyValue == 'boot':
                #Tell the board to restart in bootloader mode
                microcontroller.on_next_reset(microcontroller.RunMode.BOOTLOADER)
            elif keyValue == 'safe':
                #Tell the board to restart in safe mode
                microcontroller.on_next_reset(microcontroller.RunMode.SAFE_MODE)
            microcontroller.reset() #Reset the controller.
    except ValueError:
        pass #Do nothing. Shit happens.

# Sends a release signal to the target PC if a key is released. Not always necessary, depending on key type.
# Params:
#   key - Dictionary - Key object generated by initializeLayerMap.
#   alterStatus - Boolean - Can forcefully release a key while it's in debounce. Used for HOLD and Double-Tap functionality.
def release(key) :
    try: 

        global layer

        if key['altFunc'] == keymap.DT and (not key['tap']) :
            key['tap']    = True # Start the double tap timer
            key['status'] = 0
            return
            
        releaseValue  = key['value']
        releaseType   = key['type']
        key['status'] = 0 # set the "status" of the key to zero so it can be pressed again
        key['tap']    = False

        if key['debounce'] :
            releaseValue = key['altValue']
            releaseType  = key['altType']
        

        if releaseType == keymap.KEY:
            kbd.release(releaseValue)
        elif releaseType == keymap.LSW:
            layer = 0

        key['dt']       = 0 # Set the delta time back to zero 
        key['debounce'] = False
    except ValueError:
        pass #Do nothing. Shit happens.

# --- MAIN LOOP ---
while True:
    
    # Check for encoder inputs
    for encoder in range(len(keymap.encoder_map)) :
        encoderIndex = tsar.checkEncoder(keymap.encoder_map[encoder])
        if encoderIndex != None :
            # Todo this should return the tuple, not the index.
            cc.send(keymap.encoder_map[encoder]['keymap'][layer][encoderIndex][1])

    # Check for toggle inputs
    for toggle in range(len(keymap.toggle_map)) :
        toggleAction = tsar.checkToggle(keymap.toggle_map[toggle])
        if toggleAction and toggleAction[0] == keymap.KEY :
            kbd.press(toggleAction[1])
            kbd.release(toggleAction[1])
        elif toggleAction and toggleAction[0] == keymap.MED :
            cc.send(toggleAction[1])
        elif toggleAction and toggleAction[0] == keymap.FUNC :
            getattr(tsar, toggleAction[1])()

    # Check for normal key inputs
    for col in range(len(COLS)):
        switches[COLS[col]].value = True #Turn on the column pin to provide power and allow us to check which rows are switched on.

        for row in range(len(userKeymap[layer])):
            thisRow = userKeymap[layer][row] #This is just a less verbose way to refer to the current row later.
            if (col > (len(thisRow) -1)):
                continue
            key = thisRow[col] #This is the current key we're checking to see if it's been pressed.
            if not key :
                continue
            # If the key's status is zero and it has a value, it has just been pressed.
            if key['status'] == 0 and switches[ROWS[row]].value and (not key['altFunc'] == keymap.DT) :
                keyPress(key, False)
            elif key['status'] == 0 and switches[ROWS[row]].value and key['altFunc'] == keymap.DT and (not key['tap']) :
                key['status'] = 1
                continue

            if  key['status'] == 0 and (not switches[ROWS[row]].value) and key['tap'] :
                key['dt'] += 1

            #If the threshold for double tap is exceeded, press the normal key
            if key['status'] == 0 and (not switches[ROWS[row]].value) and key['tap'] and key['dt'] == DT_THRESHOLD :
                keyPress(key, False)
            elif key['status'] == 0 and switches[ROWS[row]].value and key['tap'] and key['dt'] < DT_THRESHOLD :
                keyPress(key, True)
                key['debounce'] = True

            if key['status'] == 1 and switches[ROWS[row]].value and key['altFunc'] == keymap.HOLD:
                # Hold functionality goes here.
                key['dt'] += 1 # Increment the deltaTime on the key and check to see if we reached the threshold yet.
                if (key['dt']) == HOLD_THRESHOLD :
                    keyPress(key, True)
                    key['debounce'] = True
                    
            elif key['status'] == 1 and (not switches[ROWS[row]].value) and key['altFunc'] == keymap.HOLD :
                if key['dt'] > 0 and key['dt'] < HOLD_THRESHOLD :
                    keyPress(key, False) # The key was released prior to the hold finishing
            

            if key['status'] == 1 and not(switches[ROWS[row]].value) :
               release(key)

        switches[COLS[col]].value = False #Turn the pin back off when we're done with this column.

    time.sleep(0.01) #debounce to stop chatter.